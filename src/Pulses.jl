export Pulse

export Envelope
export CosEnvelope
export RectEnvelope

export PulseEdge
export SineEdge

export AnalogPulse
export DigitalPulse
export DCPulse

export make_RectEnvelope
export make_Delay
export make_CosEnvelope
export make_SineEdge

"""
Subtypes of this abstract type are meant to be inputs to `DigitalPulse` and `AnalogPulse`
functions; this input informs the function which kind of windowing to apply to a pulse.
"""
abstract type Envelope end


abstract type CosEnvelope <: Envelope end
abstract type RectEnvelope <: Envelope end
abstract type Delay <: Envelope end

"""
Subtypes of this abstract type are meant to be inputs to the `DCPulse` function;
this input informs the function which kind of edges to synthesize for a DC pulse.
"""
abstract type PulseEdge end

abstract type SineEdge <: PulseEdge end


"""
Substypes of this abstract type are handles to pulses, which will be synthesized
by the AWG. They hold, as fields, both waveform values, as well as parameters
for configuring the AWG channels which will output the pulses
"""
abstract type Pulse end

"""
An object of `AnalogPulse` is meant to be a handle to a pulse generated by using
a channel's arbitrary waveform generator to amplitude modulate the output of a
channel's Function Generator. It holds the envelope waveform which is the modulating signal,
it's duration, as well as pulse parameters used to configure the particular AWG
channel generating the pulse: IF_freq, amplitude, and  IF_phase.
"""
mutable struct AnalogPulse <: Pulse
    IF_freq::Float64
    amplitude::Float64
    IF_phase::Float64
    duration::Float64
    envelope::Waveform

    AnalogPulse(IF_freq, amplitude, IF_phase) = new(IF_freq, amplitude, IF_phase)

    AnalogPulse(IF_freq, amplitude, IF_phase, duration) =
               new(IF_freq, amplitude, IF_phase, duration)

    AnalogPulse(IF_freq, amplitude, IF_phase, duration, env) =
               new(IF_freq, amplitude, IF_phase, duration, env)
end

"""
           AnalogPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{CosEnvelope},
                       sample_rate::Real, IF_phase::Real = 0)
           AnalogPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{RectEnvelope},
                       sample_rate::Real, IF_phase::Real = 0)


Function for making objetcs of the `AnalogPulse` type. Besides fields on the type,
this function also takes as input singleton objects of subtypes of the abstract type
`Envelope`; this input determines what kind of envelope will be synthesized to be
used as a modulating signal.
"""
function AnalogPulse end

function AnalogPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{CosEnvelope},
                    sample_rate::Real, IF_phase::Real = 0; name = "CosEnvelope_"*
                    string(amplitude)*"_"*string(duration))
        env = Waveform(make_CosEnvelope(duration, sample_rate), name)
        pulse = AnalogPulse(IF_freq, amplitude, IF_phase, duration, env)
        return pulse
end

function AnalogPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{RectEnvelope},
                     sample_rate::Real, IF_phase::Real = 0; name = "RectEnvelope_"*
                     string(amplitude)*"_"*string(duration))
        env = Waveform(make_RectEnvelope(duration, sample_rate), name)
        pulse = AnalogPulse(IF_freq, amplitude, IF_phase, duration, env)
        return pulse
end


"""
An object of `AnalogPulse` is meant to be a handle to a pulse generated by using
a channel's arbitrary waveform generator to amplitude modulate the output of a
channel's Function Generator. It holds the envelope waveform which is the modulating signal,
it's duration, as well as pulse parameters used to configure the particular AWG
channel generating the pulse: IF_freq, amplitude, and  IF_phase.

DigitalPulse is meant to represent a Pulse generated entirely via a channel's arbitrary
waveform generator, i.e., it's output is the channel's ouput. It holds the I and Q
waveforms which are meant to be directly outputted from the I and Q channels of the
AWG, as well as parameters used to generate these waveforms:IF_freq, IF_phase, and
duration. It also holds amplitude information, which is used to configure the
I and Q channels of the AWG.
"""
mutable struct DigitalPulse <: Pulse
    IF_freq::Float64
    amplitude::Float64 #loaded waveforms are normalized, this field is used to set actual amplitude
    IF_phase::Float64
    duration::Float64
    I_waveform::Waveform
    Q_waveform::Waveform

    DigitalPulse(IF_freq, amplitude, IF_phase) = new(IF_freq, amplitude, IF_phase)

    DigitalPulse(IF_freq, amplitude, IF_phase, duration) =
                 new(IF_freq, amplitude, IF_phase, duration)

    DigitalPulse(IF_freq, amplitude, IF_phase, duration, I_wav, Q_wav) =
                 new(IF_freq, amplitude, IF_phase, duration, I_wav, Q_wav)
end

function DigitalPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{CosEnvelope},
                      sample_rate::Real, IF_phase::Real = 0; name = "CosEnvelope_"*
                      string(amplitude)*"_"*string(duration))
    env = make_CosEnvelope(duration, sample_rate)
    pulse = DigitalPulse_general(IF_freq, amplitude, duration, env, sample_rate,
                                 IF_phase, name)
    return pulse
end

function DigitalPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{RectEnvelope},
                      sample_rate::Real, IF_phase::Real = 0; name = "CosEnvelope_"*
                      string(amplitude)*"_"*string(duration))
    env = make_RectEnvelope(duration, sample_rate)
    pulse = DigitalPulse_general(IF_freq, amplitude, duration, env, sample_rate,
                                 IF_phase, name)
    return pulse
end


mutable struct DCPulse <: Pulse
    amplitude::Float64
    duration::Float64
    waveform::Waveform

    DCPulse(amplitude, duration, waveform) = new(amplitude, duration, waveform)
    DCPulse(amplitude) = new(amplitude)
end

function DCPulse(amplitude::Real, duration::Real, ::Type{SineEdge}, sample_rate::Real;
             name = "DCPulse_"*string(amplitude)*"_"*string(duration), edge_freq = 20e6)
    rising_edge, falling_edge = make_SineEdge(sample_rate, edge_freq)
    pulse = DCPulse_general(amplitude, duration, rising_edge, falling_edge, sample_rate, name)
    return pulse
end



#helper functions

function DigitalPulse_general(IF_freq::Real, amplitude::Real, duration::Real,
                              env::Vector{Float64}, sample_rate::Real, IF_phase::Real,
                              name::AbstractString)
    time_step = 1/sample_rate; t = collect(0:time_step:duration)
    IF_signal = exp.(im*(2π*IF_freq*t + IF_phase))
    full_pulse = IF_signal.*env
    I_pulse = real(full_pulse)
    Q_pulse = imag(full_pulse)
    I_wav = Waveform(I_pulse, "I_"*name)
    Q_wav = Waveform(Q_pulse, "Q_"*name)
    pulse = DigitalPulse(IF_freq, amplitude, IF_phase, duration, I_wav, Q_wav)
    return pulse
 end

function DCPulse_general(amplitude::Real, duration::Real, rising_edge::Vector{Float64},
           falling_edge::Vector{Float64}, sample_rate::Real, name::AbstractString)
    num_t_points = Int(ceil(duration * sample_rate))
    dc_part = ones(num_t_points - size(rising_edge)[1] - size(falling_edge)[1])
    pulse_values = vcat(rising_edge, dc_part, falling_edge)
    pulse_wav = Waveform(pulse_values, name)
    pulse = DCPulse(amplitude, duration, pulse_wav)
    return pulse
end

function make_CosEnvelope(duration::Real, sample_rate::Real)
    d = duration
    time_step = 1/sample_rate
    t = collect(0:time_step:d)
    env = (1 + cos.(2π*(t - d/2)/d))/2
    return env
end

function make_RectEnvelope(duration::Real, sample_rate::Real)
    d = duration
    time_step = 1/sample_rate
    t = collect(0:time_step:d); num_points = size(t)[1]
    env = ones(num_points)
    return env
end

function make_Delay(duration::Real, sample_rate::Real)
    d = duration
    time_step = 1/sample_rate
    num_points = round(duration/time_step)
    env = zeros(num_points)
    return env
end

function make_SineEdge(sample_rate::Real, edge_freq::Real)
    edge_length = 0.25*(1/edge_freq)
    edge_length_rising = floor(edge_length, 9)
    edge_length_falling = ceil(edge_length, 9)
    rise_t = collect(0:(1/sample_rate):edge_length_rising)
    fall_t = collect(0:(1/sample_rate):edge_length_falling)
    rising_edge = sin.(2*π*edge_freq*rise_t)
    falling_edge = sin.(2*π*edge_freq*fall_t + π/2)
    return rising_edge, falling_edge
end
