export Pulse

export Envelope
export CosEnvelope
export RectEnvelope

export PulseEdge
export SineEdge

export AnalogPulse
export DigitalPulse
export DCPulse

export make_RectEnvelope
export make_Delay
export make_CosEnvelope
export make_SineEdge

"""
Subtypes of this abstract type are meant to be inputs to `DigitalPulse` and `AnalogPulse`
functions; this input informs the function which kind of windowing to apply to a pulse.
"""
abstract type Envelope end


abstract type CosEnvelope <: Envelope end
abstract type RectEnvelope <: Envelope end
abstract type Delay <: Envelope end

"""
Subtypes of this abstract type are meant to be inputs to the `DCPulse` function;
this input informs the function which kind of edges to synthesize for a DC pulse.
"""
abstract type PulseEdge end

abstract type SineEdge <: PulseEdge end


"""
Substypes of this abstract type are handles to pulses, which will be synthesized
by the AWG. They hold, as fields, the waveform values as well as parameters
for configuring the AWG channels which will output the pulses
"""
abstract type Pulse end

"""
An object of `AnalogPulse` is meant to be a handle to a pulse generated by using
a channel's arbitrary waveform generator to amplitude modulate the output of a
channel's Function Generator. It holds the envelope waveform which is the modulating signal,
it's duration, as well as pulse parameters used to configure the particular AWG
channel generating the pulse: IF_freq, amplitude, and  IF_phase.
"""
mutable struct AnalogPulse <: Pulse
    IF_freq::Float64
    amplitude::Float64
    IF_phase::Float64
    duration::Float64
    envelope::Waveform

    AnalogPulse(IF_freq, amplitude, IF_phase) = new(IF_freq, amplitude, IF_phase)

    AnalogPulse(IF_freq, amplitude, IF_phase, duration) =
               new(IF_freq, amplitude, IF_phase, duration)

    AnalogPulse(IF_freq, amplitude, IF_phase, duration, env) =
               new(IF_freq, amplitude, IF_phase, duration, env)
end

"""
           AnalogPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{CosEnvelope},
                       sample_rate::Real, IF_phase::Real = 0)
           AnalogPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{RectEnvelope},
                       sample_rate::Real, IF_phase::Real = 0)


Function for making objetcs of the `AnalogPulse` type. Besides fields on the type,
this function also takes as input singleton objects of subtypes of the abstract type
`Envelope`; this input determines what kind of envelope will be synthesized to be
used as a modulating signal.
"""
function AnalogPulse end

function AnalogPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{CosEnvelope},
                    sample_rate::Real, IF_phase::Real = 0; name = "CosEnvelope_"*
                    string(amplitude)*"_"*string(duration))
        env = Waveform(make_CosEnvelope(duration, sample_rate), name)
        pulse = AnalogPulse(IF_freq, amplitude, IF_phase, duration, env)
        return pulse
end

function AnalogPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{RectEnvelope},
                     sample_rate::Real, IF_phase::Real = 0; name = "RectEnvelope_"*
                     string(amplitude)*"_"*string(duration))
        env = Waveform(make_RectEnvelope(duration, sample_rate), name)
        pulse = AnalogPulse(IF_freq, amplitude, IF_phase, duration, env)
        return pulse
end


"""
An object of `DigitalPulse` is meant to be a handle to I and Q pulses generated
directly by a channel's arbitrary waveform generator, which eventually are used
to make a ~GHz pulse (along with an IQ mixer). It holds both the I and Q
waveforms, the pulse's duration,as well as the amplitude of the pulse, which is used
to configure the I and Q channels of the AWG.
"""
mutable struct DigitalPulse <: Pulse
    IF_freq::Float64
    amplitude::Float64 #loaded waveforms are normalized, this field is used to set actual amplitude
    IF_phase::Float64
    duration::Float64
    I_waveform::Waveform
    Q_waveform::Waveform

    DigitalPulse(IF_freq, amplitude, IF_phase) = new(IF_freq, amplitude, IF_phase)

    DigitalPulse(IF_freq, amplitude, IF_phase, duration) =
                 new(IF_freq, amplitude, IF_phase, duration)

    DigitalPulse(IF_freq, amplitude, IF_phase, duration, I_wav, Q_wav) =
                 new(IF_freq, amplitude, IF_phase, duration, I_wav, Q_wav)
end


"""
           DigitalPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{CosEnvelope},
                      sample_rate::Real, IF_phase::Real = 0)
           DigitalPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{RectEnvelope},
                      sample_rate::Real, IF_phase::Real = 0)

Function for making objetcs of the `DigitalPulse` type. Besides fields on the type,
this function also takes as input singleton objects of subtypes of the abstract type
`Envelope`; this input determines what kind of envelope will be synthesized to be
multiplied to the periodic signal to make the final I and Q waveforms
"""
function DigitalPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{CosEnvelope},
                      sample_rate::Real, IF_phase::Real = 0; name = "CosEnvelope_"*
                      string(amplitude)*"_"*string(duration))
    env = make_CosEnvelope(duration, sample_rate)
    pulse = DigitalPulse_general(IF_freq, amplitude, duration, env, sample_rate,
                                 IF_phase, name)
    return pulse
end

function DigitalPulse(IF_freq::Real, amplitude::Real, duration::Real, ::Type{RectEnvelope},
                      sample_rate::Real, IF_phase::Real = 0; name = "CosEnvelope_"*
                      string(amplitude)*"_"*string(duration))
    env = make_RectEnvelope(duration, sample_rate)
    pulse = DigitalPulse_general(IF_freq, amplitude, duration, env, sample_rate,
                                 IF_phase, name)
    return pulse
end

"""
An object of the `DCPulse` subtype is meant to be a handle to square pulses which
are used to entangle two qubits; where the pulse is generated directly by a channel's
arbitrary waveform generator. It holds the actual pulse waveform, as well as
it's duration and amplitude information to configure the channel that will be outputting the pulse
"""
mutable struct DCPulse <: Pulse
    amplitude::Float64
    duration::Float64
    waveform::Waveform

    DCPulse(amplitude, duration, waveform) = new(amplitude, duration, waveform)
    DCPulse(amplitude) = new(amplitude)
end

"""
            DCPulse(amplitude::Real, duration::Real, ::Type{SineEdge}, sample_rate::Real,
                      edge_freq = 20e6)

Function for making objetcs of the `DCPulse` type. Besides fields on the type,
this function also takes as input singleton objects of subtypes of the abstract type
`Edge`; this input determines what kind of edges the square pulse will have.
"""
function DCPulse(amplitude::Real, duration::Real, ::Type{SineEdge}, sample_rate::Real;
             name = "DCPulse_"*string(amplitude)*"_"*string(duration), edge_freq::Real = 20e6)
    rising_edge, falling_edge = make_SineEdge(sample_rate, edge_freq)
    pulse = DCPulse_general(amplitude, duration, rising_edge, falling_edge, sample_rate, name)
    return pulse
end



#helper functions

function DigitalPulse_general(IF_freq::Real, amplitude::Real, duration::Real,
                              env::Vector{Float64}, sample_rate::Real, IF_phase::Real,
                              name::AbstractString)
    time_step = 1/sample_rate; t = collect(0:time_step:duration)
    IF_signal = exp.(im*(2π*IF_freq*t + IF_phase))
    full_pulse = IF_signal.*env
    I_pulse = real(full_pulse)
    Q_pulse = imag(full_pulse)
    I_wav = Waveform(I_pulse, "I_"*name)
    Q_wav = Waveform(Q_pulse, "Q_"*name)
    pulse = DigitalPulse(IF_freq, amplitude, IF_phase, duration, I_wav, Q_wav)
    return pulse
 end

function DCPulse_general(amplitude::Real, duration::Real, rising_edge::Vector{Float64},
           falling_edge::Vector{Float64}, sample_rate::Real, name::AbstractString)
    num_t_points = Int(ceil(duration * sample_rate))
    dc_part = ones(num_t_points - size(rising_edge)[1] - size(falling_edge)[1])
    pulse_values = vcat(rising_edge, dc_part, falling_edge)
    pulse_wav = Waveform(pulse_values, name)
    pulse = DCPulse(amplitude, duration, pulse_wav)
    return pulse
end

function make_CosEnvelope(duration::Real, sample_rate::Real)
    d = duration
    time_step = 1/sample_rate
    t = collect(0:time_step:d)
    env = (1 + cos.(2π*(t - d/2)/d))/2
    return env
end

function make_RectEnvelope(duration::Real, sample_rate::Real)
    d = duration
    time_step = 1/sample_rate
    t = collect(0:time_step:d); num_points = size(t)[1]
    env = ones(num_points)
    return env
end

function make_Delay(duration::Real, sample_rate::Real)
    d = duration
    time_step = 1/sample_rate
    num_points = round(duration/time_step)
    env = zeros(num_points)
    return env
end

function make_SineEdge(sample_rate::Real, edge_freq::Real)
    edge_length = 0.25*(1/edge_freq)
    edge_length_rising = floor(edge_length, 9)
    edge_length_falling = ceil(edge_length, 9)
    rise_t = collect(0:(1/sample_rate):edge_length_rising)
    fall_t = collect(0:(1/sample_rate):edge_length_falling)
    rising_edge = sin.(2*π*edge_freq*rise_t)
    falling_edge = sin.(2*π*edge_freq*fall_t + π/2)
    return rising_edge, falling_edge
end
